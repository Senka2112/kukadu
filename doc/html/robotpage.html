<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>kukadu: The robot module</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">kukadu
   &#160;<span id="projectnumber">0.1a</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">The robot module </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The <a class="el" href="group__Robot.html">Robot</a> module is the interface to a concrete robot. It provides an interface that defines what kukadu expects a robot to be able to do. If this interface is implemented for a specific robot, the complete stack of the framework is available.</p>
<p>The major interface is the abstract <a class="el" href="classkukadu_1_1ControlQueue.html" title="Interface between the kukadu software stack and the robot hardware. If kukadu shall support another r...">kukadu::ControlQueue</a> class. It defines all the functions that are available for a robot (e.g. a robotic arm) without the robot base. If you want to bind kukadu to the robot in your lab, you have to implement the pure virtual functions of the <a class="el" href="classkukadu_1_1ControlQueue.html" title="Interface between the kukadu software stack and the robot hardware. If kukadu shall support another r...">kukadu::ControlQueue</a>. Currently, there exist 2 implementations of <a class="el" href="classkukadu_1_1ControlQueue.html" title="Interface between the kukadu software stack and the robot hardware. If kukadu shall support another r...">kukadu::ControlQueue</a>:</p>
<ul>
<li><a class="el" href="classkukadu_1_1KukieControlQueue.html" title="Contains an implementation of the control queue interface for robots supporting the IISKukie system...">kukadu::KukieControlQueue</a>: Binds the kukadu framework to robots for which the <a href="https://iis.uibk.ac.at/intranet/projects/robot/armtopics">kukie</a> framework is available. Kukie is a robot control framework based on ROS that defines certain topics and services for low-level robot control. Check out the kukie page to find out, if kukie is available for your system.</li>
<li><a class="el" href="classkukadu_1_1PlottingControlQueue.html" title="Contains an implementation of the control queue interface. The PlottingControlQueue is not bound to a...">kukadu::PlottingControlQueue</a>: Provides the kukadu functionility independent of the actual robot. With the <a class="el" href="classkukadu_1_1PlottingControlQueue.html" title="Contains an implementation of the control queue interface. The PlottingControlQueue is not bound to a...">kukadu::PlottingControlQueue</a> no robot can be controlled, but it can be used as dummy robot in order to test other functionality. The <a class="el" href="classkukadu_1_1PlottingControlQueue.html" title="Contains an implementation of the control queue interface. The PlottingControlQueue is not bound to a...">kukadu::PlottingControlQueue</a> simply ignores all submitted control commands.</li>
</ul>
<h1><a class="el" href="classkukadu_1_1KukieControlQueue.html" title="Contains an implementation of the control queue interface for robots supporting the IISKukie system...">kukadu::KukieControlQueue</a></h1>
<p>The following code snippet shows how to use the <a class="el" href="classkukadu_1_1KukieControlQueue.html" title="Contains an implementation of the control queue interface for robots supporting the IISKukie system...">kukadu::KukieControlQueue</a>. In order to make the program run, make sure that the kukie system is started (e.g. by starting the simulator or the real robot). </p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;<span class="preprocessor">#include &lt;kukadu/kukadu.hpp&gt;</span></div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;<span class="keyword">using namespace </span>std;</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;<span class="keyword">using namespace </span>kukadu;</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** args) {</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;    cout &lt;&lt; <span class="stringliteral">&quot;setting up ros node&quot;</span> &lt;&lt; endl;</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;    ros::init(argc, args, <span class="stringliteral">&quot;kukadu_controlqueue_demo&quot;</span>); ros::NodeHandle node; sleep(1);</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;    ros::AsyncSpinner spinner(10); spinner.start();</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;    cout &lt;&lt; <span class="stringliteral">&quot;setting up control queue&quot;</span> &lt;&lt; endl;</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;    <span class="keyword">auto</span> realLeftQueue = make_shared&lt;KukieControlQueue&gt;(<span class="stringliteral">&quot;simulation&quot;</span>, <span class="stringliteral">&quot;left_arm&quot;</span>, node);</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;</div>
<div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;    cout &lt;&lt; <span class="stringliteral">&quot;starting queue&quot;</span> &lt;&lt; endl;</div>
<div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;    <span class="keyword">auto</span> realLqThread = realLeftQueue-&gt;startQueue();</div>
<div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;</div>
<div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;    cout &lt;&lt; <span class="stringliteral">&quot;switching to impedance mode if it is not there yet&quot;</span> &lt;&lt; endl;</div>
<div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;    <span class="keywordflow">if</span>(realLeftQueue-&gt;getCurrentMode() != KukieControlQueue::KUKA_JNT_IMP_MODE) {</div>
<div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;        realLeftQueue-&gt;stopCurrentMode();</div>
<div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;        realLeftQueue-&gt;switchMode(KukieControlQueue::KUKA_JNT_IMP_MODE);</div>
<div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;    }</div>
<div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;</div>
<div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;    <span class="comment">// joint point to point movement in order to go to the start position</span></div>
<div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;    <span class="comment">// remark: you only define where to go, not how to get there</span></div>
<div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;    realLeftQueue-&gt;jointPtp(stdToArmadilloVec({-1.0, 1.0, -0.5, 0.0, 0.0, 0.0, 0.0}));</div>
<div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;</div>
<div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;    <span class="comment">// retrieving the current joint state of the robot after the joint</span></div>
<div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;    <span class="comment">// point to point movement</span></div>
<div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;    <span class="keyword">auto</span> startState = realLeftQueue-&gt;getCurrentJoints().joints;</div>
<div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;</div>
<div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;    <span class="comment">// execution a trajectory for the 3rd joint (i.e. rotation the arm)</span></div>
<div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;    <span class="comment">// here you also provide HOW to get to the target</span></div>
<div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;    <span class="keywordflow">for</span>(<span class="keyword">auto</span> currentState = startState; currentState(2) &lt; startState(2) + 1.0; currentState(2) += 0.005) {</div>
<div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;        <span class="comment">// sending a the next desired position</span></div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;        realLeftQueue-&gt;move(currentState);</div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;        <span class="comment">// the queue has an intrinsic clock, so you can wait until the packet has been</span></div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;        <span class="comment">// submit in order to not send the positions too fast</span></div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;        realLeftQueue-&gt;synchronizeToQueue(1);</div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;    }</div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;</div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;    cout &lt;&lt; <span class="stringliteral">&quot;execution done&quot;</span> &lt;&lt; endl;</div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;</div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;    <span class="comment">/****** done with moving? --&gt; clean up everything and quit *******/</span></div>
<div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;</div>
<div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;    <span class="comment">// leaves the mode for robot movement</span></div>
<div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;    realLeftQueue-&gt;stopCurrentMode();</div>
<div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;</div>
<div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;    <span class="comment">// stops the queue</span></div>
<div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;    realLeftQueue-&gt;stopQueue();</div>
<div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;</div>
<div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;    <span class="comment">// waits until everything has stopped</span></div>
<div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;    realLqThread-&gt;join();</div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;</div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;}</div>
</div><!-- fragment --><h2>Code description</h2>
<p>Lets have a closer look to the tutorial code. First of all, the kukadu library needs to be included (line 1). All kukadu functionality is contained in the kukadu namespace (line 4). kukadu is a framework embedded in ROS, so the first action that should be done is setting up the ros connection (lines 8 - 10).</p>
<p>The direct connection to the robot is given by the <a class="el" href="classkukadu_1_1ControlQueue.html" title="Interface between the kukadu software stack and the robot hardware. If kukadu shall support another r...">kukadu::ControlQueue</a> interface. This means that an implementation of that interface should be instantiated per robot. This is done line 13 where an instance of the <a class="el" href="classkukadu_1_1KukieControlQueue.html" title="Contains an implementation of the control queue interface for robots supporting the IISKukie system...">kukadu::KukieControlQueue</a> is created for the left arm in simulation. In line 16, the queue is started - so the queue is ready to go. However, you can't move the robot until it is switched to an appropriate control mode (lines 19 - 22). Afterwards, the robot is ready to go, so you should pay special attention to it.</p>
<p>In the first step, we can make the robot arm move by a simple point to point movement (line 26). This means that you don't need to take care how the robot reaches the desired position. All the path planning is done automatically by the system and you only need to execute the <a class="el" href="classkukadu_1_1ControlQueue.html#ad11059100321b24a1af8ef7de8314353" title="Implements simple point to point movement in joint space (blocks until target reached) ...">kukadu::ControlQueue::jointPtp()</a> function (there is also a method for <a class="el" href="classkukadu_1_1ControlQueue.html#a1bfa23a8ce6319f6ef0ed9208e896054" title="Implements simple point to point movement in cartesian space. ">kukadu::ControlQueue::cartesianPtp()</a>). This function blocks until the last packet is sent to the robot - however, it is not guaranteed that the robot reaches that position with precision. You can check if it was precise enough by looking at the returned joint positions.</p>
<p>After the PtP execution the program retrieves the current joint state of the robot with the kukadu::Controlqueue::getCurrentJoints() function. There is also a function for the Cartesian state named <a class="el" href="classkukadu_1_1ControlQueue.html#a9e79e1d0d9697bbf146d66a2d01fea9e" title="Returns current robot position in cartesian space. ">kukadu::ControlQueue::getCurrentCartesianPose()</a>.</p>
<p>The final step of the demo program is the execution of a specific trajectory. In this case you can not only define the target but also the path the robot should use to get there. In general, the <a class="el" href="classkukadu_1_1ControlQueue.html" title="Interface between the kukadu software stack and the robot hardware. If kukadu shall support another r...">kukadu::ControlQueue</a> is a clocked queue that submits one joint packet per clock cycle. This packet is then submitted to the robot. If no new packet is set, then the robot is commanded to stay at the current position. In lines 34 - 40, a specific trajectory is submitted to the queue by added one packet per clock cycle using the <a class="el" href="classkukadu_1_1ControlQueue.html#aca70a978b2950d7c9ab99d55c5977eec" title="Adds next joint position to the end of the queue (can be used for trajectory following) ...">kukadu::ControlQueue::move()</a> function. This procedure is synchronized to the queue by the <a class="el" href="classkukadu_1_1ControlQueue.html#a324484e79a5505656a32d9f32054e5d0" title="Blocks, if more than the defined maximum element count is in the queue. ">kukadu::ControlQueue::synchronizeToQueue()</a> function. This function blocks until at most N packets (in this case N = 1) is left in the queue. This makes sure that your program stays in synch with the queue. However, if you dont use this function, all packets are added to the queue at once and the queue sent on packet per clock cycle. However, you need to make sure to synchronize with the queue otherwise then.</p>
<p>In lines 44 - 53, the queue is disconnected from the robot. The most important part is to leave the execution mode (line 47). After leaving the execution mode, the queue is stopped (line 50) and the program waits until the queue is stopped completely (line 53).</p>
<p>Prev (<a class="el" href="modulespage.html">Modules</a>), Next (<a class="el" href="kinematicspage.html">The kinematics module</a>) </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue May 31 2016 21:20:22 for kukadu by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
