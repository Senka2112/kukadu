#include "DMPReinforcer.h"
#include "../utils/gnuplot-cpp/gnuplot_i.hpp"

using namespace std;
using namespace arma;

DMPReinforcer::DMPReinforcer(CostComputer* cost, ControlQueue* movementQueue, double ac, double dmpStepSize, double tolAbsErr, double tolRelErr) {
	this->cost = cost;
	this->movementQueue = movementQueue;
	this->ac = ac;
	this->dmpStepSize = dmpStepSize;
	this->tolAbsErr = tolAbsErr;
	this->tolRelErr = tolRelErr;
	this->isFirstIteration = true;
	this->lastCost = -1.0;
}

bool DMPReinforcer::getIsFirstIteration() {
	return isFirstIteration;
}

double DMPReinforcer::getLastRolloutCost() {
	return lastCost;
}

Dmp DMPReinforcer::getLastRolloutParameters() {
	return rollout;
}

t_executor_res DMPReinforcer::getLastExecutionResults() {
	return dmpResult;
}

double DMPReinforcer::getDmpStepSize() {
	return dmpStepSize;
}

double DMPReinforcer::getTolAbsErr() {
	return tolAbsErr;
}

double DMPReinforcer::getTolRelErr() {
	return tolRelErr;
}

void DMPReinforcer::performRollout(int doSimulation, int doExecution) {
	
	char cont = 'y';
	vector<Gnuplot*> gs;
	Gnuplot* g1 = NULL;
	
	if(isFirstIteration) {
		rollout = getInitialRollout();
		isFirstIteration = false;
	}
	else rollout = computeRolloutParamters();
	
	DMPExecutor dmpsim(rollout);
	
	if(doSimulation) {
		
		cout << "(DMPReinforcer) simulating rollout" << endl;
		
		dmpResult = dmpsim.simulateDMP(0, rollout.getTmax(), dmpStepSize, tolAbsErr, tolRelErr);

		for(int plotTraj = 0; plotTraj < rollout.getDegreesOfFreedom(); ++plotTraj) {

			ostringstream convert;   // stream used for the conversion
			convert << plotTraj;
			
			string title = string("fitted sensor data (joint") + convert.str() + string(")");
			g1 = new Gnuplot(title);
			g1->set_style("lines").plot_xy(dmpResult.t, dmpResult.y[plotTraj], "dmp y");
			g1->showonscreen();
			
			gs.push_back(g1);

		}

		for(int i = 0; i < gs.size(); ++i) {
			g1 = gs.at(i);
			delete g1;
		}

	}
	
	if(doExecution) {
		
		cout << "(DMPReinforcer) do you want to execute this trajectory? (y/N) ";
		cin >> cont;
	
		if(doExecution && (cont == 'y' || cont == 'Y')) {
			
			cout << "(DMPReinforcer) executing rollout" << endl;
			
			double* tmp = createDoubleArrayFromArmaVector(rollout.getY0());
			float* startingJoints = new float[rollout.getDegreesOfFreedom()];
			for(int i = 0; i < rollout.getDegreesOfFreedom(); ++i) startingJoints[i] = tmp[i];
			
			movementQueue->setStartingJoints(startingJoints);
			movementQueue->setStiffness(2200, 300, 1.0, 15000, 150, 2.0);
			thread* thr = movementQueue->startQueueThread();
			
			DMPExecutor dmpexec(rollout);
			dmpResult = dmpsim.runDMP(ac, 0, rollout.getTmax(), dmpStepSize, tolAbsErr, tolRelErr, movementQueue);
			
			movementQueue->setFinish();
			thr->join();
			
		}
		
	}
	
	double delta = cost->computeCost(dmpResult);
	lastCost = delta;

}