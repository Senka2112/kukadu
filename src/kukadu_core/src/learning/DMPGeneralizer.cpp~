#include "DMPGeneralizer.h"

using namespace std;
using namespace arma;

DMPGeneralizer::DMPGeneralizer(string baseFolder, int degOfFreedom, vector<double> tmpmys, vector<double> tmpsigmas, double az, double bz) {
	
	this->baseFolder = baseFolder;
	vector<string> files = getFilesInDirectory(baseFolder);
	queryFiles = sortPrefix(files, "query");
	trajFiles = sortPrefix(files, "traj");
	queryPoints = mapFiles(queryFiles, trajFiles, "query", "traj");
	TrajectoryDMPLearner* dmpLearner;
	
	taus.set_size(queryPoints.size());
	axs.set_size(queryPoints.size());
	
	double tau = 0.0;
	double ax = 0.0;
	dmp_base_set baseDef;
	
	for(int i = 0; i < queryPoints.size(); ++i) {
		
		mat joints = readMovements((string(baseFolder) + string(queryPoints.at(i).fileDataPath)).c_str(), degOfFreedom + 1);
		
		tau = joints(joints.n_rows - 1, 0);
		ax = -log(0.1) / tau / tau;
		
		taus(i) = tau;
		axs(i) = ax;
		
		queryPoints.at(i).queryPoint = readQuery(string(baseFolder) + string(queryPoints.at(i).fileQueryPath));

		baseDef = buildDMPBase(tmpmys, tmpsigmas, ax, tau);
		dmpLearner = new TrajectoryDMPLearner(baseDef, tau, az, bz, ax, joints, degOfFreedom);
		cout << tau << " " << ax << endl;
		t_learned_dmp learnedDmps = dmpLearner->fitTrajectories();
		cout << "blub2" << endl;
		queryPoints.at(i).dmp = learnedDmps;
		
		cout << "(DMPGeneralizer) goals for query point [";
		cout << queryPoints.at(i).queryPoint.t();
		cout << "]" << endl;
		cout << "\t [";
		cout << queryPoints.at(i).dmp.g.t();
		cout << "]" << endl;
		
		delete dmpLearner;
		
	}

}

t_querypoint DMPGeneralizer::getQueryPointByIndex(int index) {
	return queryPoints.at(index);
}

int DMPGeneralizer::getQueryPointCount() {
	return queryPoints.size();
}

t_learned_dmp DMPGeneralizer::generalizeDmp(GenericKernel* trajectoryKernel, GenericKernel* parameterKernel, vec query, double beta) {
	
	t_learned_dmp ret;
	
	int queryCount = queryPoints.size();
	int degreesOfFreedom = queryPoints.at(0).dmp.degreesOfFreedom;
	int samplePointCount = queryPoints.at(0).dmp.designMatrices.at(0).n_rows;
	
	// TODO: to learn by gaussian process: y0, dy0, ddy0 (y0,... are currently taken to be constant for all movements)
	ret.tau = queryPoints.at(0).dmp.tau;
	ret.tmax = queryPoints.at(0).dmp.tmax;
	
	// assuming that startingpoints remain the same (this should also be learned?)
	ret.y0 = queryPoints.at(0).dmp.y0;
	ret.dy0 = queryPoints.at(0).dmp.dy0;
	ret.ddy0 = queryPoints.at(0).dmp.ddy0;

	ret.az = queryPoints.at(0).dmp.az;
	ret.bz = queryPoints.at(0).dmp.bz;
	ret.ax = queryPoints.at(0).dmp.ax;
	
	ret.dmpBase = queryPoints.at(0).dmp.dmpBase;

	vector<vec> sampleXs;
	for(int i = 0; i < queryCount; ++i) sampleXs.push_back(queryPoints.at(i).queryPoint);

	cout << "(DMPGeneralizer) coefficients for query point [";
	for(int j = 0; j < query.n_elem; ++j) {
		cout << query(j);
		if(j < query.n_elem - 1) cout << ", ";
	}
	cout << "]: ";
	for(int j = 0; j < degreesOfFreedom; ++j) {
		
		vector<mat> designMatrices;
		vector<vec> sampleTs;
	
		for(int i = 0; i < queryCount; ++i) {
			sampleTs.push_back(queryPoints.at(i).dmp.fitYs.at(j));
			designMatrices.push_back(queryPoints.at(i).dmp.designMatrices.at(j));
		}
		
		LWRRegressor* reg = new LWRRegressor(sampleXs, sampleTs, trajectoryKernel, designMatrices);
		vec res = reg->fitAtPosition(query);
		ret.dmpCoeffs.push_back(res);
		
		for(int k = 0; k < res.n_elem; ++k)
			cout << res(k) << " ";
		cout << endl;

	}
	cout << endl;
	
	cout << "(DMPGeneralizer) goals for query point [";
	for(int j = 0; j < query.n_elem; ++j) {
		cout << query(j);
		if(j < query.n_elem - 1) cout << ", ";
	}
	cout << "]" << endl << "\t [ ";
	
	ret.g.set_size(degreesOfFreedom);
	for(int j = 0; j < degreesOfFreedom; ++j) {
		vec gs(queryCount);
		for(int i = 0; i < queryCount; ++i) gs(i) = queryPoints.at(i).dmp.g(j);
		GaussianProcessRegressor* reg = new GaussianProcessRegressor(sampleXs, gs, parameterKernel, beta);
		double goal = reg->fitAtPosition(query)(0);
		ret.g(j) = goal;
		
		cout << ret.g(j) << " ";
		
	}

/*
	ret->g = new vector<double>();
	ret->g->push_back(-0.187953);
	ret->g->push_back(1.33641);
	ret->g->push_back(-2.0641);
	ret->g->push_back(-1.52289);
	ret->g->push_back(-0.157403);
	ret->g->push_back(0.430357);
	ret->g->push_back(0.133002);
*/
	
	cout << "]" << endl;
	
	cout << "(DMPGeneralizer) goals for query point [";
	for(int j = 0; j < query.n_elem; ++j) {
		cout << query(j);
		if(j < query.n_elem - 1) cout << ", ";
	}
	cout << "]" << endl << "\t [ ";
	
	for(int j = 0; j < ret.g.n_elem; ++j) {
		double goal = ret.g(j);
		cout << goal << " ";
		
	}
	cout << "]" << endl;
	
	return ret;

}

vector<t_querypoint> DMPGeneralizer::mapFiles(vector<string> queryFiles, vector<string> trajFiles, string prefix1, string prefix2) {
	
	vector<t_querypoint> ret;
	
	int prefix1Size = prefix1.size();
	int prefix2Size = prefix2.size();
	int querySize = queryFiles.size();
	int trajSize = trajFiles.size();
	
	for(int i = 0; i < querySize; ++i) {
		string currentQueryFile = string(queryFiles.at(i));
		string queryAppendix = currentQueryFile.substr(prefix1Size, currentQueryFile.size() - 1);
		for(int j = 0; j < trajSize; ++j) {
			string currentTrajFile = string(trajFiles.at(j));
			string trajAppendix = currentTrajFile.substr(prefix2Size, currentTrajFile.size() - 1);
			if(!queryAppendix.compare(trajAppendix)) {
				t_querypoint toAdd;
				toAdd.fileQueryPath = queryFiles.at(i); 
				toAdd.fileDataPath = trajFiles.at(j);
				ret.push_back(toAdd);
			}
		}
	}
	
	return ret;
	
}